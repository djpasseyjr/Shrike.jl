<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Shrike.jl · Shrike.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Shrike.jl Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Shrike.jl</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Build-an-Index"><span>Build an Index</span></a></li><li><a class="tocitem" href="#KNN-Graphs"><span>KNN-Graphs</span></a></li><li><a class="tocitem" href="#Threading"><span>Threading</span></a></li><li><a class="tocitem" href="#Benchmark"><span>Benchmark</span></a></li><li><a class="tocitem" href="#Function-Documentation"><span>Function Documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Shrike.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Shrike.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/djpasseyjr/Shrike.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Shrike.jl"><a class="docs-heading-anchor" href="#Shrike.jl">Shrike.jl</a><a id="Shrike.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Shrike.jl" title="Permalink"></a></h1><p><a href="https://github.com/djpasseyjr/Shrike.jl/actions/workflows/ci.yml/badge.svg"><img src="https://github.com/djpasseyjr/Shrike.jl/actions/workflows/ci.yml/badge.svg" alt="Build Status"/></a> <a href="https://codecov.io/gh/djpasseyjr/Shrike.jl"><img src="https://codecov.io/gh/djpasseyjr/Shrike.jl/branch/main/graph/badge.svg?token=S7PNXQOLQK" alt="codecov"/></a> <a href="https://djpasseyjr.github.io/Shrike.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a></p><p><img src="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/rppartition.png" alt="Random Projection Splits"/></p><p><code>Shrike</code> is a Julia package for building ensembles of random projection trees. Random projection trees are a generalization of KD-Trees and are used to quickly approximate nearest neighbors or build k-nearest-neighbor graphs. They <a href="https://cseweb.ucsd.edu/~dasgupta/papers/rptree-stoc.pdf">conform to low dimensionality</a> that is often present in high dimensional data.</p><p>The implementation here is based on the <a href="https://helda.helsinki.fi//bitstream/handle/10138/301147/Hyvonen_Pitkanen_2016_Fast_Nearest.pdf?sequence=1">MRPT algorithm</a>. This package also includes optimizations for knn-graph creation and has built-in support for multithreading.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install just type</p><pre><code class="language-jl">] add https://github.com/djpasseyjr/Shrike.jl</code></pre><p>in the REPL or</p><pre><code class="language-jl">using Pkg
Pkg.add(path=&quot;https://github.com/djpasseyjr/Shrike.jl&quot;)</code></pre><h2 id="Build-an-Index"><a class="docs-heading-anchor" href="#Build-an-Index">Build an Index</a><a id="Build-an-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Build-an-Index" title="Permalink"></a></h2><p>To build an ensemble of random projection trees use the <code>ShrikeIndex</code> type.</p><pre><code class="language-jl">using Shrike
maxk = 100
X = rand(100, 10000)
shi = ShrikeIndex(X, maxk; depth=8, ntrees=10)</code></pre><p>The type accepts a matrix of data, <code>X</code> where each column represents a datapoint.</p><ol><li><code>maxk</code> represents the maximum number of nearest neighbors you will be able to find with this index.</li></ol><p><code>maxk</code> is used to set a safe <code>depth</code> for the tree. You can also construct an index without this parameter if you need to.</p><ol><li><code>depth</code> describes the number of times each random projection tree will split the data. Leaf nodes in the tree contain about <code>npoints / 2^depth</code> data points. Increasing <code>depth</code> increases speed but decreases accuracy. By default, the index sets depth as large as possible.</li><li><code>ntrees</code> controls the number of trees in the ensemble. More trees means more accuracy but more memory.</li></ol><p>In this case, since we need an index that can find the 100 nearest neighbors, setting <code>depth</code> equal to 8 will result in some leaf nodes with less than 100 points. The index will infer this using <code>maxk</code> and set the <code>depth</code> to be as large as possible given <code>maxk</code>. In this case, <code>depth =  6</code>.</p><p>To query the index for approximte 10 nearest neighbors use:</p><pre><code class="language-jl">k = 10
q = X[:, 1]
approx_nn = ann(shi, q, k; vote_cutoff=2)</code></pre><ol><li>The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search. Each tree &quot;votes&quot; for the points a leaf node, so if there aren&#39;t many point in the leaves and there aren&#39;t many trees, the odds of a point receiving more than one vote is low.  Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy. When <code>depth</code> is large and <code>ntrees</code> is less than 5, it is reccomended to set <code>vote_cutoff = 1</code>.</li></ol><h2 id="KNN-Graphs"><a class="docs-heading-anchor" href="#KNN-Graphs">KNN-Graphs</a><a id="KNN-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#KNN-Graphs" title="Permalink"></a></h2><p>This package includes fast algorithms to generate k-nearest-neighbor graphs and has specialized functions for this purpose. It uses neighbor of neighbor exploration (outlined <a href="https://arxiv.org/pdf/1602.00370.pdf">here</a>) to efficiently improve the accuracy of a knn-graph.</p><p>Nearest neighbor graphs are used to give a sparse topology to large datasets. Their structure can be used to <a href="https://arxiv.org/pdf/1602.00370.pdf">project the data</a> onto a lower dimensional manifold, to cluster datapoints with community detection algorithms or to preform other analyses.</p><p>To generate nearest neighbor graphs:</p><pre><code class="language-jl">using Shrike
X = rand(100, 10000)
shi = ShrikeIndex(X; depth=6, ntrees=5)
k = 10
g = knngraph(shi, k; vote_cutoff=1, ne_iters=1, gtype=SimpleDiGraph)</code></pre><ol><li>The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search.</li><li><code>ne_iters</code> controlls how many iterations of neighbor exploration the algorithm will undergo. Successive iterations are increasingly fast. It is reccomened to use more iterations of neighbor exploration when the number of trees is small and less when many trees are used.</li><li>The <code>gtype</code> parameter allows the user to specify a <code>LightGraphs.jl</code> graph type to return. <code>gtype=identity</code> returns a sparse adjacency matrix.</li></ol><p>If an array of nearest neighbor indices is preferred,</p><pre><code class="language-jl">nn = allknn(shi, k; vote_cutoff=1, ne_iters=0)</code></pre><p>can be used to generate an <code>shi.npoints</code>x<code>k</code> array of integer indexes where <code>nn[i, :]</code> corresponds to the nearest neighbors of <code>X[:, i]</code>. The keyword arguments work in the same way as in <code>knngraph</code> (outlined above).</p><h2 id="Threading"><a class="docs-heading-anchor" href="#Threading">Threading</a><a id="Threading-1"></a><a class="docs-heading-anchor-permalink" href="#Threading" title="Permalink"></a></h2><p><code>Shrike</code> has built in support for multithreading. To allocate multiple threads, start <code>julia</code> with the <code>--threads</code> flag:</p><pre><code class="language-console">user@sys:~$ julia --threads 4</code></pre><p>To see this at work, consider a small scale example:</p><pre><code class="language-console">user@sys:~$ cmd=&quot;using Shrike; shi=ShrikeIndex(rand(100, 10000)); @time knngraph(shi, 10, ne_iters=1)&quot;
user@sys:~$ julia -e &quot;$cmd&quot;
  12.373127 seconds (8.66 M allocations: 4.510 GiB, 6.85% gc time, 18.88% compilation time)
user@sys:~$ julia  --threads 4 -e &quot;$cmd&quot;
  6.306410 seconds (8.67 M allocations: 4.498 GiB, 13.12% gc time, 31.64% compilation time)</code></pre><p>(This assumes that <code>Shrike</code> is installed.)</p><h2 id="Benchmark"><a class="docs-heading-anchor" href="#Benchmark">Benchmark</a><a id="Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark" title="Permalink"></a></h2><p>This package was compared to the original <a href="https://github.com/vioshyvo/mrpt"><code>mrpt</code></a> C++ implementation (on which this algorithm was based), <a href="https://github.com/spotify/annoy"><code>annoy</code></a>, a popular package for approximate nearest neighbors, and <a href="https://github.com/KristofferC/NearestNeighbors.jl"><code>NearestNeighbors.jl</code></a>, a Julia package for nearest neighbor search. The benchmarks were written in the spirit of <a href="https://github.com/erikbern/ann-benchmarks"><code>ann-benchmarks</code></a>, a repository for comparing different approximate nearest neighbor algorithms. The datasets used for the benchmark were taken directly from <code>ann-benchmarks</code>. The following are links to the HDF5 files in question: <a href="http://ann-benchmarks.com/fashion-mnist-784-euclidean.hdf5">FashionMNIST</a>, <a href="http://ann-benchmarks.com/sift-128-euclidean.hdf5">SIFT</a>, <a href="http://ann-benchmarks.com/mnist-784-euclidean.hdf5">MNIST</a> and <a href="http://ann-benchmarks.com/gist-960-euclidean.hdf5">GIST</a>. The benchmarks below were run on a compute cluster, restricting all algorithms to a single thread.</p><p><img src="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/fashionmnist_bm.png" alt="FashionMNIST Speed Comparison"/></p><p>In this plot, up and to the right is better. (Faster queries, better recall). Each point represents a parameter combination. For a full documentation of parameters run and timing methods consult the original scripts located in the <code>benchmark/</code> directory.</p><p>This plot illustrates how for this dataset, on most parameter combinations, <code>Shrike</code> has better preformance. Compared to SIFT, below, where some parameter combinations are not as strong. We speculate that this has to do with the high dimensionality of points in FashionMNIST (d=784), compared to the lower dimensionality of SIFT (d=128).</p><p><img src="https://github.com/djpasseyjr/Shrike.jl/raw/main/docs/src/images/sift_bm.png" alt="SIFT Speed Comparison"/></p><p>It is important to note that <code>NearestNeighbors.jl</code> was designed to return the <em>exact</em> k-nearest-neighbors as quickly as possible, and does not approximate, hence the high accuracy and lower speed.</p><p>The takeaway here is that <code>Shrike</code> is fast! It is possibly a little faster than the original C++ implementation. Go Julia! We should note, that <code>Shrike</code> was <em>not</em> benchmarked against state of the art algorithms for approximate nearest neighbor search. These algorithms are faster than <code>annoy</code> and <code>mrpt</code>, but unfortunately, the developers of <code>Shrike</code> aren&#39;t familiar with these algorithms.</p><h2 id="Function-Documentation"><a class="docs-heading-anchor" href="#Function-Documentation">Function Documentation</a><a id="Function-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Shrike.ShrikeIndex-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T" href="#Shrike.ShrikeIndex-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T"><code>Shrike.ShrikeIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ShrikeIndex(data::AbstractArray{T, 2}, max)k; depth::Union{Int, Float64}=Inf, ntrees::Int=5) -&gt; shi</code></pre><p>Keyword argument version of the constructor that includes intended number of nearest neighbors.</p><p>If the default <code>depth</code> is used, the constructor sets the tree depth as deep as possible given <code>max_k</code>. This way, the accuracy/memory tradeoff is determined directly by <code>ntrees</code> and the desired <code>vote_cutoff</code> (<code>vote_cutoff</code> is a parameter passed to <code>ann</code> or <code>knngraph</code>).</p><p>If an argument is passed for <code>depth</code>, constructor attempts to use the supplied <code>depth</code>, but guarentees that the depth of the tree is shallow enough to ensure that each leaf has at least k points. (Without this check, the index may return less than k neighbors when queried.)</p><p><strong>Parameters</strong></p><ol><li><code>data</code>: A (dxn) array. Each column is a datapoint with dimension <code>d</code>.</li><li><code>max_k</code>: The maximum number of neighbors that will be queried. If intend</li></ol><p>to use the <code>ShrikeIndex</code> to approximate at most 10 nearest neigbors of a point, set <code>max_k = 10</code>. This argument is used to infer the deepest tree depth possible so as to maximize speed,</p><p><strong>Keyword Arguments</strong></p><ol><li><code>ntrees</code>: The number of trees in the index. More trees means more accuracy,</li></ol><p>more memory and less speed. Use this to tune the speed/accuracy tradeoff.</p><ol><li><code>depth</code>: The number of splits in the tree. Depth of 0 means only a root,</li></ol><p>depth of 1 means root has two children, etc..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/Shrike.jl/blob/5a480be5c15c29cf46cf0a423fb10ff9570b58a5/src/shrike_index.jl#L84-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Shrike.ShrikeIndex-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T" href="#Shrike.ShrikeIndex-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T"><code>Shrike.ShrikeIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ShrikeIndex(data::Array{T, 2}, depth::Int, ntrees::Int) where T -&gt; ensemble</code></pre><p>Constructor for ensemble of sparse random projection trees with voting. Returns <code>ShrikeIndex</code> type. (An ensemble of multiple random projection trees.)</p><p>** Type Fields**</p><ul><li><code>data::Array{T, 2}</code>: Contains all data points</li><li><code>npoints::Int</code>: Number of data points</li><li><code>ndims::Int</code>: Dimensionality of the data</li><li><code>depth::Int</code>: maximum depth of the tree. (Depth of 0 means only a root, depth of 1 means root has two children)</li><li><code>ntrees::Int</code>: Number of trees to make</li><li><code>random_vectors::AbstractArray</code>: The random projections used to make the tree</li><li><code>splits::Array{T, 2}</code>: The split values for each node in each tree stored in a 2D array</li><li><code>indexes::Array{Array{Int,1}, 2}</code>: 2D array of datapoint indexes at each leaf node in each tree.</li></ul><p>Note that RP forest does not store indexes at non-leaf nodes.</p><p>Follows the implementation outlined in:</p><blockquote><p><strong>Fast Nearest Neighbor Search through Sparse Random Projections and Voting.</strong> Ville Hyvönen, Teemu Pitkänen, Sotirios Tasoulis, Elias Jääsaari, Risto Tuomainen, Liang Wang, Jukka Ilmari Corander, Teemu Roos. Proceedings of the 2016 IEEE Conference on Big Data (2016)</p></blockquote><p>with some modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/Shrike.jl/blob/5a480be5c15c29cf46cf0a423fb10ff9570b58a5/src/shrike_index.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Shrike.ann-Union{Tuple{T}, Tuple{ShrikeIndex{T}, AbstractMatrix{T}, Int64}} where T" href="#Shrike.ann-Union{Tuple{T}, Tuple{ShrikeIndex{T}, AbstractMatrix{T}, Int64}} where T"><code>Shrike.ann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">approx_knn(shi::ShrikeIndex{T}, q::Array{T, 2}, k::Int; vote_cutoff=1) where T -&gt; knn_idx</code></pre><p>For a query point <code>q</code>, find the approximate <code>k</code> nearest neighbors from the data stored in the the ShrikeIndex. The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/Shrike.jl/blob/5a480be5c15c29cf46cf0a423fb10ff9570b58a5/src/nearest_neighbors.jl#L158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Shrike.knngraph-Union{Tuple{G}, Tuple{T}, Tuple{ShrikeIndex{T}, Int64}} where {T, G}" href="#Shrike.knngraph-Union{Tuple{G}, Tuple{T}, Tuple{ShrikeIndex{T}, Int64}} where {T, G}"><code>Shrike.knngraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">knngraph(shi::ShrikeIndex{T}, k::Int, vote_cutoff; vote_cutoff::Int=1, ne_iters::Int=0, gtype::G) where {T, G} -&gt; g</code></pre><p>Returns a graph with <code>shi.npoints</code> node and <code>k * shi.npoints</code> edges datapoints conneceted to nearest neighbors</p><p><strong>Parameters</strong></p><ol><li><code>shi</code>: random forest of the desired data</li><li><code>k</code>: the desired number of nearest neighbors</li><li><code>vote_cutoff</code>: signifies how many &quot;votes&quot; a point needs in order to be included</li></ol><p>in a linear search through leaf nodes. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy. Passing too large of a <code>vote_cutoff</code> results in the algorithm resetting <code>vote_cutoff</code> to equal the number of trees.</p><ol><li><code>ne_iters</code>: assigns the number of iterations of neighbor exploration to use. Defaults to zero.</li></ol><p>Neighbor exploration is a way to increse knn-graph accuracy.</p><ol><li><code>gtype</code> is the type of graph to construct. Defaults to <code>SimpleDiGraph</code>. <code>gtype=identity</code> returns a sparse adjacency matrix.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/Shrike.jl/blob/5a480be5c15c29cf46cf0a423fb10ff9570b58a5/src/nearest_neighbors.jl#L393-L409">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>explore(i::Int, data::AbstractArray{T}, ann::Array{NeighborExplorer{T}, 1}) where T</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Shrike.allknn-Union{Tuple{T}, Tuple{ShrikeIndex{T}, Int64}} where T" href="#Shrike.allknn-Union{Tuple{T}, Tuple{ShrikeIndex{T}, Int64}} where T"><code>Shrike.allknn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allknn(shi::ShrikeIndex{T}, k::Int; vote_cutoff::Int=1, ne_iters::Int=0) where T -&gt; approxnn_array</code></pre><p>Returns a <code>shi.npoints</code> by <code>k</code> array of approximate nearest neighbor indexes. That is, <code>approxnn_array[i,:]</code> contains the indexes of the k nearest neighbors of <code>shi.data[:, i]</code>.</p><p><strong>Parameters</strong></p><ol><li>The <code>ne_iters</code> assigns the number of iterations of neighbor exploration to use.</li></ol><p>Neighbor exploration is an inexpensive way to increase accuracy.</p><p>2, The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy. Passing too large of a <code>vote_cutoff</code> results in the algorithm resetting <code>vote_cutoff</code> to equal the number of trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/Shrike.jl/blob/5a480be5c15c29cf46cf0a423fb10ff9570b58a5/src/nearest_neighbors.jl#L346-L361">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>traverse_tree(shi::ShrikeIndex{T}, x::Array{T, 2}) where T</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 29 July 2021 13:21">Thursday 29 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
